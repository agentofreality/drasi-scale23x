<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drasi: A New Take on Change-Driven Architectures</title>
  <link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css">
  <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" id="theme">
  <link rel="stylesheet" href="node_modules/reveal.js/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="css/custom.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- ============================================================ -->
      <!-- TITLE -->
      <!-- ============================================================ -->
      <section data-background-image="images/water-ripple.jpg" data-background-opacity="0.25">
        <img src="images/drasi-logo.svg" alt="Drasi" style="width: 320px; margin-bottom: 0.3em; filter: drop-shadow(0 0 20px rgba(66,175,250,0.4));">
        <h3>A New Take on Change-Driven Architectures</h3>
        <p>
          <small>Allen Jones ‚Äî SCaLE 23x</small>
        </p>
        <p>
          <small>
            <a href="https://drasi.io">drasi.io</a> ¬∑
            <a href="https://github.com/drasi-project">github.com/drasi-project</a>
          </small>
        </p>
        <aside class="notes">
          Welcome. Today we're going to talk about a different way to think about
          reacting to data changes ‚Äî and an open-source project that makes it practical.
        </aside>
      </section>

      <!-- ============================================================ -->
      <!-- I. THE PROBLEM -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/data-center.jpg" data-background-opacity="0.2">
          <h2>The Problem</h2>
          <h4>Detecting and Reacting to Change is Harder Than It Should Be</h4>
          <aside class="notes">
            This is the premise of the entire talk. Everyone in this room has
            dealt with this ‚Äî let the statement sit for a moment.
          </aside>
        </section>

        <section>
          <h3>A Familiar Scenario</h3>
          <ul>
            <li class="fragment">You have data spread across multiple systems</li>
            <li class="fragment">Data changes (i.e. add, update, delete)</li>
            <li class="fragment">Your system needs to detect the change and react</li>
          </ul>
          <p class="fragment callout">Quickly. Precisely. Reliably.</p>
          <aside class="notes">
            Databases, APIs, Kubernetes resources ‚Äî data is everywhere.
            When something changes, other parts of the system need to detect it and react.
            This should be a solved problem by now. It isn't.
          </aside>
        </section>

        <section>
          <h3>Example: Proactive Customer Care</h3>
          <p>A shipping carrier marks a delivery as "delayed" ‚Äî your
            e-commerce platform needs to identify affected customers,
            check their loyalty tier, and offer compensation
            <em>before</em> they complain</p>
          <aside class="notes">
            The carrier system doesn't know your customers or their loyalty tier.
            The reaction must cross system boundaries.
          </aside>
        </section>

        <section>
          <h3>Example: Supply Chain Deadlines</h3>
          <p>A supplier committed to delivering parts by a deadline,
            but the warehouse receiving system <em>hasn't</em> logged
            an arrival ‚Äî production planning needs to adjust the
            schedule before the line stops</p>
          <aside class="notes">
            Absence of change ‚Äî detecting something that didn't happen.
            No single system monitors this gap.
          </aside>
        </section>

        <section>
          <h3>Example: Field Service Dispatch</h3>
          <p>Maintain a live set of technicians who are near an open
            high-priority ticket, certified for the equipment, and not
            already dispatched ‚Äî across GPS, ticketing, HR, and
            dispatch systems</p>
          <aside class="notes">
            Dynamic collection whose membership changes constantly
            across four separate systems. Tracking who's in/out is the hard part.
          </aside>
        </section>

        <section>
          <h3>These are Change-Driven Systems</h3>
          <blockquote style="border-left-color: #42affa; font-size: 0.9em;">
            Systems that do something in response to a <strong>meaningful change</strong> ‚Äî
            or the <strong>absence of change</strong> ‚Äî in relevant data.
          </blockquote>
          <aside class="notes">
            This is the definition we'll use for the rest of the talk.
            The key words are "meaningful" and "absence" ‚Äî both are important.
          </aside>
        </section>

      </section>

      <!-- ============================================================ -->
      <!-- II. BUILDING CHANGE-DRIVEN SYSTEMS TODAY -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/focus-lens.jpg" data-background-opacity="0.15">
          <h2>Building Change-Driven Systems</h2>
          <h4>How Teams Do It Today</h4>
        </section>

        <!-- ‚îÄ‚îÄ POLLING: Description + Diagram ‚îÄ‚îÄ -->
        <section>
          <h3>üîÑ Approach 1: Polling</h3>
          <p style="font-size: 0.8em; max-width: 86%; margin: 0 auto 1em;">
            The simplest approach ‚Äî your application queries the data store on a fixed interval,
            compares results to what it saw last time, and reacts to anything that changed.
          </p>
          <img src="images/polling-diagram.svg"
               alt="Polling flow: Timer/Scheduler ‚Üí Query Database ‚Üí Compare Results ‚Üí Act on Difference ‚Üí repeat"
               style="width: 92%; max-width: 860px; display: block; margin: 0.4em auto 0;">
          <aside class="notes">
            Polling is everyone's first solution. Intuitive, easy to implement,
            requires no new infrastructure. Just query and compare.
            But this simplicity comes at a cost that becomes very apparent as the system grows.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ POLLING: Challenges ‚îÄ‚îÄ -->
        <section>
          <h3>Polling: The Challenges</h3>
          <div class="split-slide">
            <div class="split-col">
              <ul style="font-size: 0.85em;">
                <li class="fragment"><strong>Latency</strong> ‚Äî Detection lag equals the poll interval; faster reaction means more polling</li>
                <li class="fragment"><strong>Wasted Resources</strong> ‚Äî Most queries return nothing; you're taxing the DB even when nothing changed</li>
                <li class="fragment"><strong>State Management</strong> ‚Äî Every consumer must store and compare its own "last seen" snapshot</li>
                <li class="fragment"><strong>Fan-out</strong> ‚Äî N consumers √ó M sources = N√óM polling loops hammering your databases</li>
              </ul>
            </div>
            <div class="split-col" style="display: flex; align-items: center; justify-content: center;">
              <div class="verdict-box fragment">
                <span class="verdict-emoji">üòì</span>
                <span class="verdict-text">Easy to start.<br>Doesn't scale.</span>
              </div>
            </div>
          </div>
          <aside class="notes">
            The polling interval is a false economy. Too slow ‚Üí you miss changes or react late.
            Too fast ‚Üí you overwhelm the database. There's no good answer.
            And every new consumer that needs the same data adds another polling loop.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ ANALYTICS PLATFORMS: Description + Diagram ‚îÄ‚îÄ -->
        <section>
          <h3>üìä Approach 2: Analytics Platforms</h3>
          <p style="font-size: 0.8em; max-width: 86%; margin: 0 auto 1em;">
            Bring data together in a central analytics platform ‚Äî a data warehouse or BI tool ‚Äî
            where rich queries and dashboards can surface meaningful conditions across all your data.
          </p>
          <img src="images/analytics-diagram.svg"
               alt="Analytics platform flow: multiple source systems ‚Üí ETL Pipeline (copy, mins‚Äìhours lag) ‚Üí Analytics Platform (snapshot, not live) ‚Üí Reports &amp; Alerts"
               style="width: 96%; max-width: 900px; display: block; margin: 0.4em auto 0;">
          <aside class="notes">
            Analytics platforms solve the multi-source problem beautifully.
            You can write rich queries across all your data in one place.
            But the fundamental model is retrospective ‚Äî you're analyzing a copy of data,
            not reacting to live changes.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ ANALYTICS PLATFORMS: Challenges ‚îÄ‚îÄ -->
        <section>
          <h3>Analytics Platforms: The Challenges</h3>
          <div class="split-slide">
            <div class="split-col">
              <ul style="font-size: 0.85em;">
                <li class="fragment"><strong>Data is Copied, Not Live</strong> ‚Äî Your analytics platform holds a snapshot; the real systems have already moved on</li>
                <li class="fragment"><strong>ETL Latency</strong> ‚Äî Data pipelines introduce minutes to hours of lag before changes are visible</li>
                <li class="fragment"><strong>Retrospective, Not Reactive</strong> ‚Äî Designed for answering "what happened?" ‚Äî not "act when this changes"</li>
                <li class="fragment"><strong>Operational Overhead</strong> ‚Äî Maintaining ETL pipelines, schema mappings, and sync schedules is a job in itself</li>
              </ul>
            </div>
            <div class="split-col" style="display: flex; align-items: center; justify-content: center;">
              <div class="verdict-box fragment">
                <span class="verdict-emoji">üêå</span>
                <span class="verdict-text">Limits responsiveness.<br>The data is never truly live.</span>
              </div>
            </div>
          </div>
          <aside class="notes">
            Analytics platforms are excellent at deep querying over large, historical datasets.
            But they're fundamentally the wrong tool for real-time reaction.
            You can't act on a change you haven't loaded yet.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ CDC + STREAM PROCESSING: Prevalence + Technologies ‚îÄ‚îÄ -->
        <section>
          <h3>üìã Approach 3: CDC + Stream Processing</h3>
          <p class="fragment" style="font-size: 0.82em; max-width: 86%; margin: 0 auto 0.8em;">
            Change Data Capture reads every row-level change from the database transaction log
            and streams it in real time ‚Äî paired with stream processing engines for
            filtering, joining, and transformation. The dominant approach in serious production systems today.
          </p>
          <p class="fragment" style="font-size: 0.72em; opacity: 0.7; margin-bottom: 0.5em;">A rich, mature, battle-tested ecosystem:</p>
          <div class="source-grid fragment" style="font-size: 0.8em; gap: 0.4em;">
            <span class="source-badge">Debezium</span>
            <span class="source-badge">Apache Kafka</span>
            <span class="source-badge">Kafka Connect</span>
            <span class="source-badge">Apache Flink</span>
            <span class="source-badge">Apache Spark Streaming</span>
            <span class="source-badge">AWS Kinesis</span>
            <span class="source-badge">Azure Event Hubs</span>
            <span class="source-badge">Google Pub/Sub</span>
            <span class="source-badge">Confluent Platform</span>
            <span class="source-badge">Materialize</span>
            <span class="source-badge">ksqlDB</span>
            <span class="source-badge">RisingWave</span>
          </div>
          <aside class="notes">
            This is genuinely powerful technology, used by some of the world's largest systems.
            We're not dismissing it. But let's look at what building a change-driven solution
            on top of these actually looks like in practice.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ CDC + STREAM PROCESSING: Example Diagram ‚îÄ‚îÄ -->
        <section>
          <h3>CDC + Stream Processing: In Practice</h3>
          <img src="images/cdc-diagram.svg"
               alt="CDC pipeline: Database ‚Üí Debezium ‚Üí Kafka Topic ‚Üí Stream Processor ‚Üí Consumer App, plus required supporting infrastructure"
               style="width: 96%; max-width: 920px; display: block; margin: 0.4em auto 0;">
          <aside class="notes">
            Each box is a separate system to deploy, configure, and operate.
            Each arrow is a contract to maintain ‚Äî schemas, serialization formats, offsets.
            And we haven't even discussed what the consumer application itself has to do.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ CDC + STREAM PROCESSING: Complexity Challenges ‚îÄ‚îÄ -->
        <section>
          <h3>The Complexity Cost</h3>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.8em; margin-top: 1em;">
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üîß</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">Ops Burden</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Clusters, connectors, registries ‚Äî all yours to run</div>
            </div>
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üîÄ</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">Schema Evolution</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Changes ripple through the entire pipeline</div>
            </div>
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üíª</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">Consumer Logic</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Filtering, joins, dedup ‚Äî still your code</div>
            </div>
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üîó</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">Cross-Source Joins</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Windowing and state management required</div>
            </div>
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üìÖ</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">Time to Production</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Weeks from idea to running system</div>
            </div>
            <div class="fragment" style="text-align: center; padding: 0.6em;">
              <div style="font-size: 1.8em;">üòì</div>
              <div style="font-size: 0.75em; font-weight: bold; margin: 0.3em 0;">The Bottom Line</div>
              <div style="font-size: 0.6em; opacity: 0.8;">Most effort is plumbing, not business logic</div>
            </div>
          </div>
          <aside class="notes">
            Notice that most of this complexity isn't business logic ‚Äî it's plumbing.
            You're spending engineering time managing infrastructure instead of
            expressing what you actually care about.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ CDC + STREAM PROCESSING: Broader Context ‚îÄ‚îÄ -->
        <section>
          <h3>A Powerful Tool ‚Äî For a Different Job</h3>
          <div class="split-slide">
            <div class="split-col">
              <h4>‚úÖ CDC + Streaming Excels At</h4>
              <ul>
                <li class="fragment">Audit logs &amp; event sourcing</li>
                <li class="fragment">Data replication &amp; sync</li>
                <li class="fragment">General-purpose pub/sub pipelines</li>
                <li class="fragment">High-throughput event fan-out</li>
              </ul>
            </div>
            <div class="split-col">
              <h4>‚ö†Ô∏è Change-Driven Systems Still Require</h4>
              <ul>
                <li class="fragment">Significant engineering to express <em>what matters</em></li>
                <li class="fragment">Custom consumer code per condition</li>
                <li class="fragment">State stores to detect result-set transitions</li>
                <li class="fragment">Re-engineering when conditions change</li>
              </ul>
            </div>
          </div>
          <p class="fragment" style="font-size: 0.72em; margin-top: 1em; line-height: 1.5;">
            These platforms are <strong>event-driven</strong> infrastructure ‚Äî excellent at moving events at scale.<br>
            Building a sophisticated <strong>change-driven</strong> solution on top requires substantial
            engineering, configuration, and ongoing maintenance that never ends.
          </p>
          <aside class="notes">
            This is the key insight. CDC and streaming are event-driven tools.
            They're designed for moving and processing events.
            Turning that raw stream into "detect when this specific business condition
            changes" requires building a substantial layer on top ‚Äî and that's exactly what teams end up doing.
          </aside>
        </section>

        <!-- ‚îÄ‚îÄ EVENT-DRIVEN vs CHANGE-DRIVEN ‚îÄ‚îÄ -->
        <section>
          <h3>Event-Driven vs Change-Driven</h3>
          <div class="fragment" style="margin-top: 0.8em;">
            <p style="font-size: 0.8em; opacity: 0.6; margin-bottom: 0.3em;"><strong>Event-Driven</strong></p>
            <blockquote style="border-left-color: rgba(66,175,250,0.35);">
              "Here's everything that happened.<br>Figure out what you care about."
            </blockquote>
          </div>
          <div class="fragment" style="margin-top: 1.2em;">
            <p style="font-size: 0.8em; margin-bottom: 0.3em;"><strong>Change-Driven</strong></p>
            <blockquote style="border-left-color: #42affa;">
              "Tell me exactly what you care about.<br>I'll tell you when it changes."
            </blockquote>
          </div>
          <p class="fragment" style="font-size: 0.7em; margin-top: 1.2em; opacity: 0.75; line-height: 1.5;">
            Event-driven puts the burden of <em>meaning</em> on every consumer.<br>
            Change-driven lets you <em>declare</em> what matters ‚Äî once ‚Äî and get exactly that signal, nothing more.
          </p>
          <aside class="notes">
            This is the key mental shift. Let both blockquotes land before moving on.
            The event-driven model is producer-centric: here's what happened, you figure out relevance.
            The change-driven model inverts this entirely: you declare what matters,
            and the platform tells you precisely when it changes.
          </aside>
        </section>


      </section>

      <!-- ============================================================ -->
      <!-- III. INTRODUCING DRASI (merged with How It Works) -->
      <!-- ============================================================ -->
      <section>
        <section>
          <img src="images/drasi-logo.svg" alt="Drasi" style="width: 260px; margin-bottom: 0.2em; filter: drop-shadow(0 0 16px rgba(66,175,250,0.35));">
          <h2>Introducing Drasi</h2>
          <aside class="notes">
            Now that we've set up the paradigm, let's meet the project.
          </aside>
        </section>

        <section>
          <h3>What is Drasi?</h3>
          <p class="fragment" style="font-size: 1.15em; max-width: 85%; margin: 0.8em auto;">
            An open-source platform that <strong>continuously evaluates your queries</strong> against live data and pushes <strong>typed change events</strong> to your reactions ‚Äî no polling, no consumer-side state, no filter logic.
          </p>
          <p class="fragment" style="font-size: 0.7em; opacity: 0.6; margin-top: 1.5em;">
            CNCF Sandbox ¬∑ Apache 2.0 ¬∑ Works with your existing databases and systems
          </p>
        </section>

        <section>
          <h3>Core Mental Model</h3>
          <div class="pipeline">
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">üóÑÔ∏è</span>
              <span class="pipeline-label">Sources</span>
            </div>
            <span class="pipeline-arrow fragment">‚Üí</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">üîç</span>
              <span class="pipeline-label">Continuous Queries</span>
            </div>
            <span class="pipeline-arrow fragment">‚Üí</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">‚ö°</span>
              <span class="pipeline-label">Reactions</span>
            </div>
          </div>
          <p class="fragment" style="margin-top: 1em; font-size: 0.75em; opacity: 0.7;">Three concepts. That's the entire platform.</p>
          <aside class="notes">
            This is the entire data flow. Three concepts ‚Äî that's it.
          </aside>
        </section>

        <section>
          <h3>Sources</h3>
          <p>Connect to your existing data</p>
          <div class="source-grid">
            <span class="source-badge">PostgreSQL</span>
            <span class="source-badge">MySQL</span>
            <span class="source-badge">SQL Server</span>
            <span class="source-badge">Cosmos DB</span>
            <span class="source-badge">Kubernetes</span>
            <span class="source-badge">Event Hubs</span>
            <span class="source-badge">Dataverse</span>
          </div>
          <p class="fragment" style="font-size: 0.65em; margin-top: 1.2em; opacity: 0.6;">No new databases or queues required ‚Äî connects to what you already run</p>
          <aside class="notes">
            Sources connect to your existing infrastructure. No new databases or queues required.
          </aside>
        </section>

        <section>
          <h3>Continuous Queries</h3>
          <p>Declarative queries that run <strong>perpetually</strong> in <strong>openCypher</strong> or <strong>GQL</strong></p>
          <p><small>Simple ‚Äî find all delayed orders</small></p>
          <pre><code class="language-cypher" data-trim>
MATCH (o:Order)
WHERE o.status = 'delayed'
RETURN o
          </code></pre>
          <div class="fragment">
            <p><small>Cross-source ‚Äî orders with customer details from different databases</small></p>
            <pre><code class="language-cypher" data-trim>
MATCH (o:Order)-[:PLACED_BY]->(c:Customer)
WHERE o.total > 1000
RETURN o, c.name, c.email
            </code></pre>
          </div>
          <aside class="notes">
            This is where the magic happens. Your query defines what "change" means.
            Queries maintain a live result set and can span multiple sources.

            DIFFERENTIATION vs streaming SQL (Materialize, ksqlDB, RisingWave):
            1. Graph-native query language (Cypher/GQL) ‚Äî not SQL. Natural for relationship-rich data.
            2. Multi-source joins across heterogeneous systems (Postgres + Cosmos DB + K8s) ‚Äî not just Kafka topics.
            3. Built-in reaction system ‚Äî detection AND action in one platform.
            4. Embeddable via drasi-lib Rust crate ‚Äî runs in-process at the edge.
            If someone asks: "Drasi is for change detection across your existing systems.
            Streaming SQL is for stream processing on event streams. Different problem shapes."
          </aside>
        </section>

        <section>
          <h3>Reactions</h3>
          <p>Act when query results change</p>
          <div class="source-grid">
            <span class="source-badge">Webhooks</span>
            <span class="source-badge">SignalR</span>
            <span class="source-badge">SSE</span>
            <span class="source-badge">Event Grid</span>
            <span class="source-badge">Debezium</span>
            <span class="source-badge">Dapr</span>
            <span class="source-badge">Stored Procs</span>
            <span class="source-badge">Gremlin</span>
            <span class="source-badge">Dataverse</span>
          </div>
          <p class="fragment" style="font-size: 0.65em; margin-top: 1.2em; opacity: 0.6;">One query ‚Üí many reactions ¬∑ One reaction ‚Üí many queries</p>
          <aside class="notes">
            Three change types: added, updated, deleted. Clean, typed, unambiguous.
            Any combination of queries and reactions can be wired together.
          </aside>
        </section>

        <section>
          <h3>Deployment Options</h3>
          <div class="deployment-options">
            <div class="deployment-option fragment">
              <img src="images/rust-logo.png" alt="Rust" class="deployment-icon">
              <h4>drasi-lib</h4>
              <p>Rust crate ¬∑ Embedded in-process<br><small>Edge ¬∑ IoT ¬∑ Custom pipelines</small></p>
            </div>
            <div class="deployment-option fragment">
              <img src="images/docker-logo.png" alt="Docker" class="deployment-icon">
              <h4>Drasi Server</h4>
              <p>Single binary or Docker container<br><small>No Kubernetes required</small></p>
            </div>
            <div class="deployment-option fragment">
              <img src="images/kubernetes-logo.svg" alt="Kubernetes" class="deployment-icon">
              <h4>D4K8s</h4>
              <p>Full platform with scaling &amp; observability<br><small>AKS ¬∑ EKS ¬∑ GKE</small></p>
            </div>
          </div>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- V. DEMO 1 -->
      <!-- ============================================================ -->
      <section>
        <section>
          <h2>Demo 1</h2>
          <p style="font-size: 1.05em; font-style: italic;">Let's watch Drasi detect delayed orders<br>across a live database ‚Äî in real time.</p>
          <aside class="notes">
            Foundational demo: show the core flow end-to-end with a concrete scenario.
            Next slide is the live demo ‚Äî click into it to interact.
          </aside>
        </section>

        <section data-background-iframe="http://localhost:8080/ui/?instance=demo-1" data-background-interactive>
          <aside class="notes">
            Live demo. Press Esc to exit interactive mode and advance slides.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VI. PATTERNS & ADVANCED CAPABILITIES -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/network-abstract.jpg" data-background-opacity="0.2">
          <h2>Patterns &amp; Advanced Capabilities</h2>
        </section>

        <section>
          <h3>Multi-Source Queries</h3>
          <ul>
            <li class="fragment">Join data across <strong>heterogeneous systems</strong> in a single query</li>
            <li class="fragment">No shared schema or common event bus required</li>
          </ul>
          <pre class="fragment"><code class="language-cypher" data-trim>
MATCH (o:Order)-[:CONTAINS]->(p:Product)
// Order from PostgreSQL, Product from Cosmos DB
WHERE p.inventory < 10
RETURN o.id, p.name, p.inventory
          </code></pre>
        </section>

        <section>
          <h3>Temporal Capabilities</h3>
          <div class="fragment">
            <p><strong>trueFor</strong></p>
            <p><small>"Alert me if a sensor stays above threshold for 5 minutes"</small></p>
          </div>
          <div class="fragment">
            <p><strong>trueLater</strong></p>
            <p><small>"Check back in 30 minutes ‚Äî did this order ship?"</small></p>
          </div>
          <aside class="notes">
            These temporal functions let you build time-aware reactive logic declaratively.
          </aside>
        </section>

        <section>
          <h3>Detecting the Absence of Change</h3>
          <p class="fragment" style="font-size: 1.1em; font-style: italic; max-width: 85%; margin: 0 auto;">
            "A patient's vitals haven't updated in 10 minutes.<br>
            Is the sensor offline ‚Äî or is it an emergency?"
          </p>
          <pre class="fragment"><code class="language-cypher" data-trim>
MATCH (p:Patient)-[:HAS_MONITOR]->(m:Monitor)
WHERE m.lastReading IS NOT NULL
  AND trueFor(m.lastReading = m.lastReading, 10, 'minutes')
RETURN p.name, p.room, m.lastReading
          </code></pre>
          <p class="fragment callout">Most event-driven systems simply can't do this.</p>
          <aside class="notes">
            This is Drasi's most differentiating capability.
            Detecting that something DIDN'T happen is as important as detecting that it did.
            Let this moment land ‚Äî it's usually the "aha" for the audience.
          </aside>
        </section>

        <section>
          <h3>AI-Driven Workloads</h3>
          <ul>
            <li class="fragment">Keep embeddings &amp; model inputs aligned with <strong>live data</strong></li>
            <li class="fragment">React to the <em>specific</em> data changes that matter to your AI pipeline</li>
            <li class="fragment"><strong>No stale context</strong> ‚Äî continuous freshness without polling</li>
          </ul>
          <aside class="notes">
            RAG pipelines, embedding updates, model retraining triggers ‚Äî
            Drasi ensures AI systems stay aligned with reality.
          </aside>
        </section>

        <section>
          <h3>Middleware Pipeline</h3>
          <p>Transform &amp; enrich incoming changes before they reach your queries</p>
          <pre class="fragment"><code class="language-json" data-trim>
// Reshape nested JSON with jq before it hits the query engine
{ "transform": ".payload | { id: .orderId, total: .items | map(.price) | add }" }
          </code></pre>
          <p class="fragment" style="font-size: 0.65em; opacity: 0.6;">Also supports: Unwind ¬∑ Decode ¬∑ Relabel ¬∑ Promote</p>
        </section>

        <section>
          <h3>The Full Picture</h3>
          <div class="placeholder-img">
            <p>üìä Architecture Diagram Placeholder</p>
            <p><small>IMAGE NEEDED: Clean Drasi architecture diagram ‚Äî multiple source icons (database, Kubernetes, API) on the left ‚Üí central "Continuous Query Engine" box ‚Üí multiple reaction icons (webhook, UI, event bus) on the right. Flat design, dark background, blue (#42affa) accents. ~1920x1080.</small></p>
          </div>
          <aside class="notes">
            This diagram shows how everything connects. Sources feed the query engine,
            which maintains live result sets and pushes changes to reactions.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VII. DEMO 2 -->
      <!-- ============================================================ -->
      <section>
        <section>
          <div class="quiz-slide">
            <div class="quiz-emoji">ü§î</div>
            <div class="quiz-question">
              What happens when an order is deleted from Postgres‚Ä¶<br>
              but the customer record in Cosmos DB still references it?
            </div>
          </div>
          <aside class="notes">
            Pause here. Let the audience think for 5 seconds.
            Then say: "Let me show you." and advance to the demo.
          </aside>
        </section>

        <section>
          <h2>Demo 2</h2>
          <p style="font-size: 1.05em; font-style: italic;">Can we catch a cross-database inconsistency<br>the moment it happens?</p>
          <aside class="notes">
            Advanced demo: multi-source joins, temporal queries, or AI/RAG scenario.
            This is the "wow" moment. Next slide is the live demo.
          </aside>
        </section>

        <section data-background-iframe="http://localhost:8080/ui/?instance=demo-2" data-background-interactive>
          <aside class="notes">
            Live demo. Press Esc to exit interactive mode and advance slides.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VIII. TAKEAWAYS & GETTING STARTED -->
      <!-- ============================================================ -->
      <section>
        <section>
          <h2>Practical Takeaways</h2>
        </section>

        <section>
          <h3>When to Reach for Drasi</h3>
          <ul>
            <li class="fragment">You need to react to <strong>specific, meaningful</strong> data changes</li>
            <li class="fragment">You're tired of building custom polling / filtering / state logic</li>
            <li class="fragment">You want to <strong>standardize</strong> change detection across your org</li>
            <li class="fragment">You're building <strong>AI systems</strong> that need continuously fresh data</li>
          </ul>
          <p class="fragment" style="font-size: 0.7em; opacity: 0.6; margin-top: 1.2em;">
            Not a replacement for your event bus or streaming platform ‚Äî it's a complement.<br>
            CNCF Sandbox ‚Äî early-stage project with a growing ecosystem.
          </p>
        </section>

        <section>
          <h3>Getting Started</h3>
          <div style="display: flex; align-items: center; justify-content: center; gap: 2em;">
            <table>
              <tbody>
                <tr>
                  <td>üìñ</td>
                  <td><a href="https://drasi.io">drasi.io</a> ‚Äî docs, tutorials, quickstarts</td>
                </tr>
                <tr>
                  <td>üíª</td>
                  <td><a href="https://github.com/drasi-project">github.com/drasi-project</a></td>
                </tr>
                <tr>
                  <td>üê≥</td>
                  <td>Try Drasi Server locally with Docker in minutes</td>
                </tr>
                <tr>
                  <td>üèõÔ∏è</td>
                  <td>CNCF Sandbox ¬∑ Open governance ¬∑ Apache 2.0</td>
                </tr>
              </tbody>
            </table>
            <img src="images/qr-drasi.svg" alt="QR code for drasi.io" style="width: 180px; height: 180px; background: white; padding: 8px; border-radius: 8px;">
          </div>
        </section>

        <section>
          <h3>Open Source &amp; Community</h3>
          <ul>
            <li class="fragment"><strong>CNCF Sandbox</strong> ‚Äî open governance, vendor-neutral home</li>
            <li class="fragment"><strong>No vendor lock-in</strong> ‚Äî runs anywhere: your laptop, your cloud, your cluster</li>
            <li class="fragment"><strong>Contribute</strong> ‚Äî Sources, Reactions, middleware, docs<br>
              <small>Rust ¬∑ Go ¬∑ TypeScript ¬∑ You pick</small></li>
          </ul>
          <p class="fragment" style="font-size: 0.75em; margin-top: 1em;">
            <a href="https://github.com/drasi-project">github.com/drasi-project</a> ‚Äî issues tagged <code>good first issue</code> are waiting for you
          </p>
        </section>

        <section>
          <h3>Try the Tutorials</h3>
          <div class="deployment-options" style="gap: 1.5em;">
            <div class="deployment-option">
              <span style="font-size: 2.5em;">üõí</span>
              <h4>Curbside Pickup</h4>
              <p>Reactive dashboards over multiple sources</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">üè¢</span>
              <h4>Building Comfort</h4>
              <p>Sensors and HVAC management</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">üîí</span>
              <h4>Risky Containers</h4>
              <p>No-code real-time security dashboard</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">ü§ñ</span>
              <h4>GitHub Bot</h4>
              <p>Automated workflows from data changes</p>
            </div>
          </div>
        </section>

        <section data-background-image="images/water-ripple.jpg" data-background-opacity="0.2">
          <img src="images/drasi-logo.svg" alt="Drasi" style="width: 200px; margin-bottom: 0.3em; filter: drop-shadow(0 0 16px rgba(66,175,250,0.35));">
          <p class="callout" style="font-size: 1.1em; margin-bottom: 1.2em;">
            Stop writing code to watch for changes.<br>
            Describe what matters. Let Drasi do the rest.
          </p>
          <div class="fragment">
            <p>
              <a href="https://drasi.io">drasi.io</a> ¬∑
              <a href="https://github.com/drasi-project">github.com/drasi-project</a>
            </p>
            <p><small>Allen Jones ¬∑ SCaLE 23x</small></p>
          </div>
        </section>
      </section>

    </div>
  </div>

  <script src="node_modules/reveal.js/dist/reveal.js"></script>
  <script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
  <script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      transition: 'slide',
      plugins: [RevealNotes, RevealHighlight]
    }).then(() => {
      // Enable trackpad/mouse scrolling in overview mode
      const revealEl = document.querySelector('.reveal');
      const slidesEl = document.querySelector('.reveal .slides');
      let pan = { x: 0, y: 0 };

      Reveal.on('overviewshown', () => { pan = { x: 0, y: 0 }; });
      Reveal.on('overviewhidden', () => {
        pan = { x: 0, y: 0 };
        slidesEl.style.translate = '';
      });

      revealEl.addEventListener('wheel', (e) => {
        if (!Reveal.isOverview()) return;
        e.preventDefault();
        e.stopImmediatePropagation();
        pan.x -= e.deltaX;
        pan.y -= e.deltaY;
        slidesEl.style.translate = pan.x + 'px ' + pan.y + 'px';
      }, { capture: true, passive: false });
    });
  </script>
</body>
</html>
