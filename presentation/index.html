<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drasi: A New Take on Change-Driven Architectures</title>
  <link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css">
  <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" id="theme">
  <link rel="stylesheet" href="node_modules/reveal.js/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="css/custom.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- ============================================================ -->
      <!-- TITLE -->
      <!-- ============================================================ -->
      <section data-background-image="images/water-ripple.jpg" data-background-opacity="0.25">
        <img src="images/drasi-logo.svg" alt="Drasi" style="width: 320px; margin-bottom: 0.3em; filter: drop-shadow(0 0 20px rgba(66,175,250,0.4));">
        <h3>A New Take on Change-Driven Architectures</h3>
        <p>
          <small>Allen Jones â€” SCaLE 23x</small>
        </p>
        <p>
          <small>
            <a href="https://drasi.io">drasi.io</a> Â·
            <a href="https://github.com/drasi-project">github.com/drasi-project</a>
          </small>
        </p>
        <aside class="notes">
          Welcome. Today we're going to talk about a different way to think about
          reacting to data changes â€” and an open-source project that makes it practical.
        </aside>
      </section>

      <!-- ============================================================ -->
      <!-- I. THE PROBLEM -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/data-center.jpg" data-background-opacity="0.2">
          <h2>The Problem</h2>
          <h4>Detecting and Reacting to Change is Harder Than It Should Be</h4>
          <aside class="notes">
            This is the premise of the entire talk. Everyone in this room has
            dealt with this â€” let the statement sit for a moment.
          </aside>
        </section>

        <section>
          <h3>A Familiar Scenario</h3>
          <ul>
            <li class="fragment">You have data spread across multiple systems</li>
            <li class="fragment">Data changes (i.e. add, update, delete)</li>
            <li class="fragment">Your system needs to detect the change and react</li>
          </ul>
          <p class="fragment callout">Quickly. Precisely. Reliably.</p>
          <aside class="notes">
            Databases, APIs, Kubernetes resources â€” data is everywhere.
            When something changes, other parts of the system need to detect it and react.
            This should be a solved problem by now. It isn't.
          </aside>
        </section>

        <section>
          <h3>Example: Proactive Customer Care</h3>
          <p>A shipping carrier marks a delivery as "delayed" â€” your
            e-commerce platform needs to identify affected customers,
            check their loyalty tier, and offer compensation
            <em>before</em> they complain</p>
          <aside class="notes">
            The carrier system doesn't know your customers or their loyalty tier.
            The reaction must cross system boundaries.
          </aside>
        </section>

        <section>
          <h3>Example: Supply Chain Deadlines</h3>
          <p>A supplier committed to delivering parts by a deadline,
            but the warehouse receiving system <em>hasn't</em> logged
            an arrival â€” production planning needs to adjust the
            schedule before the line stops</p>
          <aside class="notes">
            Absence of change â€” detecting something that didn't happen.
            No single system monitors this gap.
          </aside>
        </section>

        <section>
          <h3>Example: Field Service Dispatch</h3>
          <p>Maintain a live set of technicians who are near an open
            high-priority ticket, certified for the equipment, and not
            already dispatched â€” across GPS, ticketing, HR, and
            dispatch systems</p>
          <aside class="notes">
            Dynamic collection whose membership changes constantly
            across four separate systems. Tracking who's in/out is the hard part.
          </aside>
        </section>

        <section>
          <h3>These are Change-Driven Systems</h3>
          <blockquote style="border-left-color: #42affa; font-size: 0.9em;">
            Systems that do something in response to a <strong>meaningful change</strong> â€”
            or the <strong>absence of change</strong> â€” in relevant data.
          </blockquote>
          <aside class="notes">
            This is the definition we'll use for the rest of the talk.
            The key words are "meaningful" and "absence" â€” both are important.
          </aside>
        </section>

      </section>

      <!-- ============================================================ -->
      <!-- II. BUILDING CHANGE-DRIVEN SYSTEMS TODAY -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/focus-lens.jpg" data-background-opacity="0.15">
          <h2>Building Change-Driven Systems</h2>
          <h4>How Teams Do It Today</h4>
        </section>

        <!-- â”€â”€ POLLING: Description + Diagram â”€â”€ -->
        <section>
          <h3>ğŸ”„ Approach 1: Polling</h3>
          <p style="font-size: 0.8em; max-width: 86%; margin: 0 auto 1em;">
            The simplest approach â€” your application queries the data store on a fixed interval,
            compares results to what it saw last time, and reacts to anything that changed.
          </p>
          <div class="pipeline">
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">â±ï¸</span>
              <span class="pipeline-label">Timer /<br>Scheduler</span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ—„ï¸</span>
              <span class="pipeline-label">Query<br>Database</span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ”</span>
              <span class="pipeline-label">Compare to<br>Last Result</span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">âš¡</span>
              <span class="pipeline-label">Act on<br>Difference</span>
            </div>
          </div>
          <p class="fragment" style="font-size: 0.65em; opacity: 0.65; margin-top: 0.9em;">
            â†º Repeat every N seconds â€” forever
          </p>
          <aside class="notes">
            Polling is everyone's first solution. Intuitive, easy to implement,
            requires no new infrastructure. Just query and compare.
            But this simplicity comes at a cost that becomes very apparent as the system grows.
          </aside>
        </section>

        <!-- â”€â”€ POLLING: Challenges â”€â”€ -->
        <section>
          <h3>Polling: The Challenges</h3>
          <div class="split-slide">
            <div class="split-col">
              <ul>
                <li class="fragment"><strong>Latency</strong> â€” faster reaction = more polling</li>
                <li class="fragment"><strong>Waste</strong> â€” most queries return nothing</li>
                <li class="fragment"><strong>State</strong> â€” every consumer tracks "last seen"</li>
                <li class="fragment"><strong>Fan-out</strong> â€” N consumers Ã— M sources</li>
              </ul>
            </div>
            <div class="split-col" style="display: flex; align-items: center; justify-content: center;">
              <div class="verdict-box fragment">
                <span class="verdict-emoji">ğŸ˜“</span>
                <span class="verdict-text">Easy to start.<br>Doesn't scale.</span>
              </div>
            </div>
          </div>
          <aside class="notes">
            The polling interval is a false economy. Too slow â†’ you miss changes or react late.
            Too fast â†’ you overwhelm the database. There's no good answer.
            And every new consumer that needs the same data adds another polling loop.
          </aside>
        </section>

        <!-- â”€â”€ ANALYTICS PLATFORMS: Description + Diagram â”€â”€ -->
        <section>
          <h3>ğŸ“Š Approach 2: Analytics Platforms</h3>
          <p style="font-size: 0.8em; max-width: 86%; margin: 0 auto 1em;">
            Bring data together in a central analytics platform â€” a data warehouse or BI tool â€”
            where rich queries and dashboards can surface meaningful conditions across all your data.
          </p>
          <div class="pipeline">
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ—„ï¸</span>
              <span class="pipeline-label">Source Systems<br><small>DBs Â· APIs Â· SaaS</small></span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ”„</span>
              <span class="pipeline-label">ETL / Pipeline<br><small>Copy &amp; Load</small></span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ“Š</span>
              <span class="pipeline-label">Analytics Platform<br><small>Warehouse Â· BI Tool</small></span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ“‹</span>
              <span class="pipeline-label">Reports &amp;<br>Alerts</span>
            </div>
          </div>
          <p class="fragment" style="font-size: 0.65em; opacity: 0.65; margin-top: 0.9em;">
            Snowflake Â· BigQuery Â· Databricks Â· Power BI Â· Tableau Â· Redshift
          </p>
          <aside class="notes">
            Analytics platforms solve the multi-source problem beautifully.
            You can write rich queries across all your data in one place.
            But the fundamental model is retrospective â€” you're analyzing a copy of data,
            not reacting to live changes.
          </aside>
        </section>

        <!-- â”€â”€ ANALYTICS PLATFORMS: Challenges â”€â”€ -->
        <section>
          <h3>Analytics Platforms: The Challenges</h3>
          <div class="split-slide">
            <div class="split-col">
              <ul>
                <li class="fragment"><strong>Copied, Not Live</strong> â€” a snapshot; the real systems have moved on</li>
                <li class="fragment"><strong>ETL Latency</strong> â€” minutes to hours before changes are visible</li>
                <li class="fragment"><strong>Retrospective</strong> â€” answers "what happened?" not "act now"</li>
                <li class="fragment"><strong>Pipeline Overhead</strong> â€” ETL, schema mappings, sync schedules</li>
              </ul>
            </div>
            <div class="split-col" style="display: flex; align-items: center; justify-content: center;">
              <div class="verdict-box fragment">
                <span class="verdict-emoji">ğŸŒ</span>
                <span class="verdict-text">Great for insights.<br>Not for reacting.</span>
              </div>
            </div>
          </div>
          <aside class="notes">
            Analytics platforms are excellent at deep querying over large, historical datasets.
            But they're fundamentally the wrong tool for real-time reaction.
            You can't act on a change you haven't loaded yet.
          </aside>
        </section>

        <!-- â”€â”€ CDC + STREAM PROCESSING: Prevalence + Technologies â”€â”€ -->
        <section>
          <h3>ğŸ“‹ Approach 3: CDC + Stream Processing</h3>
          <p style="font-size: 0.78em; max-width: 86%; margin: 0 auto 0.8em;">
            Capture every row-level change from the database log and stream it in real time.
            The dominant approach in serious production systems today.
          </p>
          <div class="source-grid fragment">
            <span class="source-badge">Debezium</span>
            <span class="source-badge">Kafka</span>
            <span class="source-badge">Flink</span>
            <span class="source-badge">Spark Streaming</span>
            <span class="source-badge">Kinesis</span>
            <span class="source-badge">Event Hubs</span>
            <span class="source-badge">Materialize</span>
            <span class="source-badge">ksqlDB</span>
            <span class="source-badge">RisingWave</span>
          </div>
          <aside class="notes">
            This is genuinely powerful technology, used by some of the world's largest systems.
            We're not dismissing it. But let's look at what building a change-driven solution
            on top of these actually looks like in practice.
          </aside>
        </section>

        <!-- â”€â”€ CDC + STREAM PROCESSING: Example Diagram â”€â”€ -->
        <section>
          <h3>CDC + Stream Processing: In Practice</h3>
          <div class="pipeline pipeline-compact" style="margin: 0.8em auto 0.5em; gap: 0.2em;">
            <div class="pipeline-step">
              <span class="pipeline-icon">ğŸ—„ï¸</span>
              <span class="pipeline-label">Database<br><small>Postgres / MySQL</small></span>
            </div>
            <span class="pipeline-arrow" style="font-size: 1.6em;">â†’</span>
            <div class="pipeline-step">
              <span class="pipeline-icon">ğŸ“¡</span>
              <span class="pipeline-label">Debezium<br><small>CDC Connector</small></span>
            </div>
            <span class="pipeline-arrow" style="font-size: 1.6em;">â†’</span>
            <div class="pipeline-step">
              <span class="pipeline-icon">ğŸ“¨</span>
              <span class="pipeline-label">Kafka Topic<br><small>Raw Row Events</small></span>
            </div>
            <span class="pipeline-arrow" style="font-size: 1.6em;">â†’</span>
            <div class="pipeline-step">
              <span class="pipeline-icon">âš™ï¸</span>
              <span class="pipeline-label">Flink / Streams<br><small>Stream Processor</small></span>
            </div>
            <span class="pipeline-arrow" style="font-size: 1.6em;">â†’</span>
            <div class="pipeline-step">
              <span class="pipeline-icon">ğŸ¯</span>
              <span class="pipeline-label">Consumer App<br><small>Filter Â· Join Â· Act</small></span>
            </div>
          </div>
          <div class="fragment" style="margin-top: 0.8em; font-size: 0.68em; opacity: 0.7; line-height: 1.6;">
            <strong>Also needed:</strong>
            Schema Registry Â· Consumer Groups Â· State Stores Â· Dead-Letter Queues Â·
            Kafka Connect config Â· Connector lifecycle management Â· Lag monitoring Â· â€¦
          </div>
          <aside class="notes">
            Each box is a separate system to deploy, configure, and operate.
            Each arrow is a contract to maintain â€” schemas, serialization formats, offsets.
            And we haven't even discussed what the consumer application itself has to do.
          </aside>
        </section>

        <!-- â”€â”€ CDC + STREAM PROCESSING: Complexity Challenges â”€â”€ -->
        <section>
          <h3>The Complexity Cost</h3>
          <ul>
            <li class="fragment"><strong>Ops burden</strong> â€” Kafka clusters, connectors, schema registries, lag monitoring</li>
            <li class="fragment"><strong>Schema evolution</strong> â€” source changes ripple through every downstream consumer</li>
            <li class="fragment"><strong>Consumer logic</strong> â€” filtering, joining, stateful detection â€” still your code</li>
            <li class="fragment"><strong>Cross-source joins</strong> â€” streamâ€“stream windowing and careful state management</li>
            <li class="fragment"><strong>Time to production</strong> â€” weeks from "I need this condition" to running system</li>
          </ul>
          <aside class="notes">
            Notice that most of this complexity isn't business logic â€” it's plumbing.
            You're spending engineering time managing infrastructure instead of
            expressing what you actually care about.
          </aside>
        </section>

        <!-- â”€â”€ CDC + STREAM PROCESSING: Broader Context â”€â”€ -->
        <section>
          <h3>A Powerful Tool â€” For a Different Job</h3>
          <div class="split-slide">
            <div class="split-col">
              <h4>âœ… CDC + Streaming Excels At</h4>
              <ul>
                <li>Audit logs &amp; event sourcing</li>
                <li>Data replication &amp; sync</li>
                <li>Pub/sub pipelines</li>
                <li>High-throughput event fan-out</li>
              </ul>
            </div>
            <div class="split-col">
              <h4>âš ï¸ Change-Driven Still Requires</h4>
              <ul>
                <li>Engineering to express <em>what matters</em></li>
                <li>Custom code per condition</li>
                <li>State stores for result-set transitions</li>
                <li>Re-engineering when conditions change</li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            This is the key insight. CDC and streaming are event-driven tools.
            They're designed for moving and processing events.
            Turning that raw stream into "detect when this specific business condition
            changes" requires building a substantial layer on top â€” and that's exactly what teams end up doing.
          </aside>
        </section>

        <!-- â”€â”€ EVENT-DRIVEN vs CHANGE-DRIVEN â”€â”€ -->
        <section>
          <h3>Event-Driven vs Change-Driven</h3>
          <div class="fragment" style="margin-top: 0.6em;">
            <p style="font-size: 0.75em; opacity: 0.6; margin-bottom: 0.2em;"><strong>Event-Driven</strong></p>
            <blockquote style="border-left-color: rgba(66,175,250,0.35); font-size: 0.85em;">
              "Here's everything that happened.<br>Figure out what you care about."
            </blockquote>
          </div>
          <div class="fragment" style="margin-top: 0.8em;">
            <p style="font-size: 0.75em; margin-bottom: 0.2em;"><strong>Change-Driven</strong></p>
            <blockquote style="border-left-color: #42affa; font-size: 0.85em;">
              "Tell me exactly what you care about.<br>I'll tell you when it changes."
            </blockquote>
          </div>
          <aside class="notes">
            This is the key mental shift. Let both blockquotes land before moving on.
            The event-driven model is producer-centric: here's what happened, you figure out relevance.
            The change-driven model inverts this entirely: you declare what matters,
            and the platform tells you precisely when it changes.
          </aside>
        </section>

      </section>

      <!-- ============================================================ -->
      <!-- III. INTRODUCING DRASI (merged with How It Works) -->
      <!-- ============================================================ -->
      <section>
        <section>
          <img src="images/drasi-logo.svg" alt="Drasi" style="width: 260px; margin-bottom: 0.2em; filter: drop-shadow(0 0 16px rgba(66,175,250,0.35));">
          <h2>Introducing Drasi</h2>
          <aside class="notes">
            Now that we've set up the paradigm, let's meet the project.
          </aside>
        </section>

        <section>
          <h3>What is Drasi?</h3>
          <p class="fragment" style="font-size: 1.15em; max-width: 85%; margin: 0.8em auto;">
            An open-source <strong>Data Change Processing</strong> platform that makes it easier to build <strong>change-driven solutions</strong>.
          </p>
          <p class="fragment" style="font-size: 0.85em; max-width: 85%; margin: 0.6em auto; opacity: 0.8;">
            Continuously evaluates your queries against live data and pushes typed change events to your reactions â€” no polling, no consumer-side state, no filter logic.
          </p>
          <p class="fragment" style="font-size: 0.7em; opacity: 0.6; margin-top: 1.5em;">
            CNCF Sandbox Â· Apache 2.0 Â· Works with your existing databases and systems
          </p>
        </section>

        <section>
          <h3>Core Mental Model</h3>
          <div class="pipeline">
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ—„ï¸</span>
              <span class="pipeline-label">Sources</span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">ğŸ”</span>
              <span class="pipeline-label">Continuous Queries</span>
            </div>
            <span class="pipeline-arrow fragment">â†’</span>
            <div class="pipeline-step fragment">
              <span class="pipeline-icon">âš¡</span>
              <span class="pipeline-label">Reactions</span>
            </div>
          </div>
          <p class="fragment" style="margin-top: 1em; font-size: 0.75em; opacity: 0.7;">Three concepts. That's the entire platform.</p>
          <aside class="notes">
            This is the entire data flow. Three concepts â€” that's it.
          </aside>
        </section>

        <section>
          <h3>Sources</h3>
          <p>Connect to your existing data</p>
          <div class="source-grid">
            <span class="source-badge">PostgreSQL</span>
            <span class="source-badge">MySQL</span>
            <span class="source-badge">SQL Server</span>
            <span class="source-badge">Cosmos DB</span>
            <span class="source-badge">Kubernetes</span>
            <span class="source-badge">Event Hubs</span>
            <span class="source-badge">Dataverse</span>
          </div>
          <p class="fragment" style="font-size: 0.65em; margin-top: 1.2em; opacity: 0.6;">No new databases or queues required â€” connects to what you already run</p>
          <aside class="notes">
            Sources connect to your existing infrastructure. No new databases or queues required.
          </aside>
        </section>

        <section>
          <h3>Continuous Queries</h3>
          <p>Declarative queries that run <strong>perpetually</strong> in <strong>openCypher</strong> or <strong>GQL</strong></p>
          <p><small>Simple â€” find all delayed orders</small></p>
          <pre><code class="language-cypher" data-trim>
MATCH (o:Order)
WHERE o.status = 'delayed'
RETURN o
          </code></pre>
          <div class="fragment">
            <p><small>Cross-source â€” orders with customer details from different databases</small></p>
            <pre><code class="language-cypher" data-trim>
MATCH (o:Order)-[:PLACED_BY]->(c:Customer)
WHERE o.total > 1000
RETURN o, c.name, c.email
            </code></pre>
          </div>
          <aside class="notes">
            This is where the magic happens. Your query defines what "change" means.
            Queries maintain a live result set and can span multiple sources.

            DIFFERENTIATION vs streaming SQL (Materialize, ksqlDB, RisingWave):
            1. Graph-native query language (Cypher/GQL) â€” not SQL. Natural for relationship-rich data.
            2. Multi-source joins across heterogeneous systems (Postgres + Cosmos DB + K8s) â€” not just Kafka topics.
            3. Built-in reaction system â€” detection AND action in one platform.
            4. Embeddable via drasi-lib Rust crate â€” runs in-process at the edge.
            If someone asks: "Drasi is for change detection across your existing systems.
            Streaming SQL is for stream processing on event streams. Different problem shapes."
          </aside>
        </section>

        <section>
          <h3>Reactions</h3>
          <p>Act when query results change</p>
          <div class="source-grid">
            <span class="source-badge">Webhooks</span>
            <span class="source-badge">SignalR</span>
            <span class="source-badge">SSE</span>
            <span class="source-badge">Event Grid</span>
            <span class="source-badge">Debezium</span>
            <span class="source-badge">Dapr</span>
            <span class="source-badge">Stored Procs</span>
            <span class="source-badge">Gremlin</span>
            <span class="source-badge">Dataverse</span>
          </div>
          <p class="fragment" style="font-size: 0.65em; margin-top: 1.2em; opacity: 0.6;">One query â†’ many reactions Â· One reaction â†’ many queries</p>
          <aside class="notes">
            Three change types: added, updated, deleted. Clean, typed, unambiguous.
            Any combination of queries and reactions can be wired together.
          </aside>
        </section>

        <section>
          <h3>Deployment Options</h3>
          <div class="deployment-options">
            <div class="deployment-option fragment">
              <img src="images/rust-logo.png" alt="Rust" class="deployment-icon">
              <h4>drasi-lib</h4>
              <p>Rust crate Â· Embedded in-process<br><small>Edge Â· IoT Â· Custom pipelines</small></p>
            </div>
            <div class="deployment-option fragment">
              <img src="images/docker-logo.png" alt="Docker" class="deployment-icon">
              <h4>Drasi Server</h4>
              <p>Single binary or Docker container<br><small>No Kubernetes required</small></p>
            </div>
            <div class="deployment-option fragment">
              <img src="images/kubernetes-logo.svg" alt="Kubernetes" class="deployment-icon">
              <h4>D4K8s</h4>
              <p>Full platform with scaling &amp; observability<br><small>AKS Â· EKS Â· GKE</small></p>
            </div>
          </div>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- V. DEMO 1 -->
      <!-- ============================================================ -->
      <section>
        <section>
          <h2>Demo 1</h2>
          <p style="font-size: 1.05em; font-style: italic;">Let's watch Drasi detect delayed orders<br>across a live database â€” in real time.</p>
          <aside class="notes">
            Foundational demo: show the core flow end-to-end with a concrete scenario.
            Next slide is the live demo â€” click into it to interact.
          </aside>
        </section>

        <section data-background-iframe="http://localhost:8080/ui/?instance=demo-1" data-background-interactive>
          <aside class="notes">
            Live demo. Press Esc to exit interactive mode and advance slides.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VI. PATTERNS & ADVANCED CAPABILITIES -->
      <!-- ============================================================ -->
      <section>
        <section data-background-image="images/network-abstract.jpg" data-background-opacity="0.2">
          <h2>Patterns &amp; Advanced Capabilities</h2>
        </section>

        <section>
          <h3>Multi-Source Queries</h3>
          <ul>
            <li class="fragment">Join data across <strong>heterogeneous systems</strong> in a single query</li>
            <li class="fragment">No shared schema or common event bus required</li>
          </ul>
          <pre class="fragment"><code class="language-cypher" data-trim>
MATCH (o:Order)-[:CONTAINS]->(p:Product)
// Order from PostgreSQL, Product from Cosmos DB
WHERE p.inventory < 10
RETURN o.id, p.name, p.inventory
          </code></pre>
        </section>

        <section>
          <h3>Temporal Capabilities</h3>
          <div class="fragment">
            <p><strong>trueFor</strong></p>
            <p><small>"Alert me if a sensor stays above threshold for 5 minutes"</small></p>
          </div>
          <div class="fragment">
            <p><strong>trueLater</strong></p>
            <p><small>"Check back in 30 minutes â€” did this order ship?"</small></p>
          </div>
          <aside class="notes">
            These temporal functions let you build time-aware reactive logic declaratively.
          </aside>
        </section>

        <section>
          <h3>Detecting the Absence of Change</h3>
          <p class="fragment" style="font-size: 1.1em; font-style: italic; max-width: 85%; margin: 0 auto;">
            "A patient's vitals haven't updated in 10 minutes.<br>
            Is the sensor offline â€” or is it an emergency?"
          </p>
          <pre class="fragment"><code class="language-cypher" data-trim>
MATCH (p:Patient)-[:HAS_MONITOR]->(m:Monitor)
WHERE m.lastReading IS NOT NULL
  AND trueFor(m.lastReading = m.lastReading, 10, 'minutes')
RETURN p.name, p.room, m.lastReading
          </code></pre>
          <p class="fragment callout">Most event-driven systems simply can't do this.</p>
          <aside class="notes">
            This is Drasi's most differentiating capability.
            Detecting that something DIDN'T happen is as important as detecting that it did.
            Let this moment land â€” it's usually the "aha" for the audience.
          </aside>
        </section>

        <section>
          <h3>AI-Driven Workloads</h3>
          <ul>
            <li class="fragment">Keep embeddings &amp; model inputs aligned with <strong>live data</strong></li>
            <li class="fragment">React to the <em>specific</em> data changes that matter to your AI pipeline</li>
            <li class="fragment"><strong>No stale context</strong> â€” continuous freshness without polling</li>
          </ul>
          <aside class="notes">
            RAG pipelines, embedding updates, model retraining triggers â€”
            Drasi ensures AI systems stay aligned with reality.
          </aside>
        </section>

        <section>
          <h3>Middleware Pipeline</h3>
          <p>Transform &amp; enrich incoming changes before they reach your queries</p>
          <pre class="fragment"><code class="language-json" data-trim>
// Reshape nested JSON with jq before it hits the query engine
{ "transform": ".payload | { id: .orderId, total: .items | map(.price) | add }" }
          </code></pre>
          <p class="fragment" style="font-size: 0.65em; opacity: 0.6;">Also supports: Unwind Â· Decode Â· Relabel Â· Promote</p>
        </section>

        <section>
          <h3>The Full Picture</h3>
          <div class="placeholder-img">
            <p>ğŸ“Š Architecture Diagram Placeholder</p>
            <p><small>IMAGE NEEDED: Clean Drasi architecture diagram â€” multiple source icons (database, Kubernetes, API) on the left â†’ central "Continuous Query Engine" box â†’ multiple reaction icons (webhook, UI, event bus) on the right. Flat design, dark background, blue (#42affa) accents. ~1920x1080.</small></p>
          </div>
          <aside class="notes">
            This diagram shows how everything connects. Sources feed the query engine,
            which maintains live result sets and pushes changes to reactions.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VII. DEMO 2 -->
      <!-- ============================================================ -->
      <section>
        <section>
          <div class="quiz-slide">
            <div class="quiz-emoji">ğŸ¤”</div>
            <div class="quiz-question">
              What happens when an order is deleted from Postgresâ€¦<br>
              but the customer record in Cosmos DB still references it?
            </div>
          </div>
          <aside class="notes">
            Pause here. Let the audience think for 5 seconds.
            Then say: "Let me show you." and advance to the demo.
          </aside>
        </section>

        <section>
          <h2>Demo 2</h2>
          <p style="font-size: 1.05em; font-style: italic;">Can we catch a cross-database inconsistency<br>the moment it happens?</p>
          <aside class="notes">
            Advanced demo: multi-source joins, temporal queries, or AI/RAG scenario.
            This is the "wow" moment. Next slide is the live demo.
          </aside>
        </section>

        <section data-background-iframe="http://localhost:8080/ui/?instance=demo-2" data-background-interactive>
          <aside class="notes">
            Live demo. Press Esc to exit interactive mode and advance slides.
          </aside>
        </section>
      </section>

      <!-- ============================================================ -->
      <!-- VIII. TAKEAWAYS & GETTING STARTED -->
      <!-- ============================================================ -->
      <section>
        <section>
          <h2>Practical Takeaways</h2>
        </section>

        <section>
          <h3>When to Reach for Drasi</h3>
          <ul>
            <li class="fragment">You need to react to <strong>specific, meaningful</strong> data changes</li>
            <li class="fragment">You're tired of building custom polling / filtering / state logic</li>
            <li class="fragment">You want to <strong>standardize</strong> change detection across your org</li>
            <li class="fragment">You're building <strong>AI systems</strong> that need continuously fresh data</li>
          </ul>
          <p class="fragment" style="font-size: 0.7em; opacity: 0.6; margin-top: 1.2em;">
            Not a replacement for your event bus or streaming platform â€” it's a complement.<br>
            CNCF Sandbox â€” early-stage project with a growing ecosystem.
          </p>
        </section>

        <section>
          <h3>Getting Started</h3>
          <div style="display: flex; align-items: center; justify-content: center; gap: 2em;">
            <table>
              <tbody>
                <tr>
                  <td>ğŸ“–</td>
                  <td><a href="https://drasi.io">drasi.io</a> â€” docs, tutorials, quickstarts</td>
                </tr>
                <tr>
                  <td>ğŸ’»</td>
                  <td><a href="https://github.com/drasi-project">github.com/drasi-project</a></td>
                </tr>
                <tr>
                  <td>ğŸ³</td>
                  <td>Try Drasi Server locally with Docker in minutes</td>
                </tr>
                <tr>
                  <td>ğŸ›ï¸</td>
                  <td>CNCF Sandbox Â· Open governance Â· Apache 2.0</td>
                </tr>
              </tbody>
            </table>
            <img src="images/qr-drasi.svg" alt="QR code for drasi.io" style="width: 180px; height: 180px; background: white; padding: 8px; border-radius: 8px;">
          </div>
        </section>

        <section>
          <h3>Open Source &amp; Community</h3>
          <ul>
            <li class="fragment"><strong>CNCF Sandbox</strong> â€” open governance, vendor-neutral home</li>
            <li class="fragment"><strong>No vendor lock-in</strong> â€” runs anywhere: your laptop, your cloud, your cluster</li>
            <li class="fragment"><strong>Contribute</strong> â€” Sources, Reactions, middleware, docs<br>
              <small>Rust Â· Go Â· TypeScript Â· You pick</small></li>
          </ul>
          <p class="fragment" style="font-size: 0.75em; margin-top: 1em;">
            <a href="https://github.com/drasi-project">github.com/drasi-project</a> â€” issues tagged <code>good first issue</code> are waiting for you
          </p>
        </section>

        <section>
          <h3>Try the Tutorials</h3>
          <div class="deployment-options" style="gap: 1.5em;">
            <div class="deployment-option">
              <span style="font-size: 2.5em;">ğŸ›’</span>
              <h4>Curbside Pickup</h4>
              <p>Reactive dashboards over multiple sources</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">ğŸ¢</span>
              <h4>Building Comfort</h4>
              <p>Sensors and HVAC management</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">ğŸ”’</span>
              <h4>Risky Containers</h4>
              <p>No-code real-time security dashboard</p>
            </div>
            <div class="deployment-option">
              <span style="font-size: 2.5em;">ğŸ¤–</span>
              <h4>GitHub Bot</h4>
              <p>Automated workflows from data changes</p>
            </div>
          </div>
        </section>

        <section data-background-image="images/water-ripple.jpg" data-background-opacity="0.2">
          <img src="images/drasi-logo.svg" alt="Drasi" style="width: 200px; margin-bottom: 0.3em; filter: drop-shadow(0 0 16px rgba(66,175,250,0.35));">
          <p class="callout" style="font-size: 1.1em; margin-bottom: 1.2em;">
            Stop writing code to watch for changes.<br>
            Describe what matters. Let Drasi do the rest.
          </p>
          <div class="fragment">
            <p>
              <a href="https://drasi.io">drasi.io</a> Â·
              <a href="https://github.com/drasi-project">github.com/drasi-project</a>
            </p>
            <p><small>Allen Jones Â· SCaLE 23x</small></p>
          </div>
        </section>
      </section>

    </div>
  </div>

  <script src="node_modules/reveal.js/dist/reveal.js"></script>
  <script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
  <script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      transition: 'slide',
      plugins: [RevealNotes, RevealHighlight]
    }).then(() => {
      // Enable trackpad/mouse scrolling in overview mode
      const revealEl = document.querySelector('.reveal');
      const slidesEl = document.querySelector('.reveal .slides');
      let pan = { x: 0, y: 0 };

      Reveal.on('overviewshown', () => { pan = { x: 0, y: 0 }; });
      Reveal.on('overviewhidden', () => {
        pan = { x: 0, y: 0 };
        slidesEl.style.translate = '';
      });

      revealEl.addEventListener('wheel', (e) => {
        if (!Reveal.isOverview()) return;
        e.preventDefault();
        e.stopImmediatePropagation();
        pan.x -= e.deltaX;
        pan.y -= e.deltaY;
        slidesEl.style.translate = pan.x + 'px ' + pan.y + 'px';
      }, { capture: true, passive: false });
    });
  </script>
</body>
</html>
